#include <stdio.h>
#include <stdlib.h> // For exit()

// Include headers for components that main needs to interact with
#include "ast.h"               // If you're building an AST and need to access its root
#include "miniJava.tab.h"      // Generated by bison, contains yyparse() and token definitions
#include "semantic_analyzer.h" // Your semantic analyzer function declarations
#include "ir_generator.h"      // Include IR generator header
#include "tac.h"               // <--- CORRECTED: Include TAC header (for print_tac_code, etc.)

// This needs to be declared as extern because it's defined in lexer.yy.c
extern FILE *yyin;
extern ProgramNode *root_ast_node; // This is the variable that holds your AST root

// Declare the global semantic error count as extern
extern int semantic_error_count;

int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        fprintf(stderr, "Usage: %s <input_minijava_file>\n", argv[0]);
        return 1; // Indicate error
    }

    // Open the input file for lexer/parser
    yyin = fopen(argv[1], "r");
    if (!yyin)
    {
        perror("Could not open input file");
        return 1; // Indicate error
    }

    printf("Lexing and parsing started...\n");
    // Call the parser. It will internally call the lexer.
    int parse_result = yyparse();

    // Close yyin and destroy lexer buffers regardless of parse result
    fclose(yyin);
    // yylex_destroy(); // Uncomment if you have this function from Flex

    if (parse_result == 0)
    {
        printf("Parsing successful!\n");

        // Use the globally declared 'root_ast_node' directly,
        // as this is where your parser populates the AST.
        if (root_ast_node == NULL)
        { // Check if the AST was actually built
            fprintf(stderr, "Error: AST root is NULL after successful parsing. No AST was built.\n");
            return 1;
        }

        init_symbol_table();

        printf("Starting semantic analysis...\n");
        // Call your semantic analysis function with 'root_ast_node'
        analyze_semantics(root_ast_node);

        if (semantic_error_count == 0)
        {
            printf("Semantic analysis successful! No errors found.\n");

            // --- Intermediate Representation (IR) Generation Phase ---
            printf("Starting IR generation...\n");
            // Call your IR generation function with the AST root
            // This function should populate your global TAC list (tac_head)
            generate_ir(root_ast_node);

            // Access and print the generated TAC (assuming tac_head is populated)
            // Your tac.h declares print_tac_code() with no arguments
            // Your tac.h declares tac_head as extern TacInstruction *tac_head;
            extern TacInstruction *tac_head; // <--- CORRECTED: Use tac_head
            if (tac_head != NULL)            // Check if any instructions were generated
            {
                printf("IR generation successful! Generated Three-Address Code:\n");
                print_tac_code(); // <--- CORRECTED: Call print_tac_code with no arguments
            }
            else
            {
                fprintf(stderr, "Info: IR generation did not produce any TAC instructions (empty program?).\n");
            }
            // --- END IR GENERATION PHASE ---
        }
        else
        {
            fprintf(stderr, "Semantic analysis found %d error(s). Compiler front-end failed.\n", semantic_error_count);
            // No need to fclose(yyin) here, it's already closed.
            return 1; // Indicate semantic errors
        }
    }
    else
    {
        fprintf(stderr, "Parsing failed! Syntax errors detected. Compiler front-end failed.\n");
        // No need to fclose(yyin) here, it's already closed.
        return 1; // Indicate parsing failure
    }

    // Free AST memory
    if (root_ast_node != NULL)
    {
        printf("Freeing AST memory...\n");
        free_ast(root_ast_node); // Make sure you have a free_ast function
        root_ast_node = NULL;    // Prevent double-free if main is called again (unlikely but good practice)
    }

    // Free TAC memory (using free_tac_code as defined in your tac.h)
    // Your tac.h declares free_tac_code() with no arguments
    extern void free_tac_code(); // <--- CORRECTED: Use free_tac_code
    if (tac_head != NULL)        // Check if tac_head was populated before trying to free
    {
        printf("Freeing TAC memory...\n");
        free_tac_code(); // <--- CORRECTED: Call free_tac_code with no arguments
        tac_head = NULL; // Reset after freeing
    }

    free_symbol_table();
    return 0; // Indicate overall success
}