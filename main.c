// main.c
#include <stdio.h>
#include <stdlib.h> // For exit(), malloc, free
#include <string.h> // For strrchr, strncpy, strcpy

// Include headers for components that main needs to interact with
#include "ast.h"               // If you're building an AST and need to access its root
#include "miniJava.tab.h"      // Generated by bison, contains yyparse() and token definitions
#include "semantic_analyzer.h" // Your semantic analyzer function declarations
#include "ir_generator.h"      // Include IR generator header
#include "tac.h"               // TAC definitions and functions
#include "codegen.h"           // X86 Code generator declarations

// This needs to be declared as extern because it's defined in lexer.yy.c
extern FILE *yyin;
extern ProgramNode *root_ast_node; // This is the variable that holds your AST root

// Declare the global semantic error count as extern
extern int semantic_error_count;

// Global TAC list head (defined in tac.c)
extern TacInstruction *tac_head;

// If your lexer has a yylex_destroy function (common with Flex)
// extern int yylex_destroy(void);

// Helper function to derive output assembly filename
// from input filename (e.g., "input.java" -> "input.s")
char *get_output_asm_filename(const char *input_filename)
{
    char *output_filename = NULL;
    const char *dot = strrchr(input_filename, '.'); // Find last dot
    size_t base_len;

    if (dot)
    { // If there's an extension
        base_len = dot - input_filename;
    }
    else
    { // No extension
        base_len = strlen(input_filename);
    }

    // Allocate space for base_name + ".s" + null terminator
    output_filename = (char *)malloc(base_len + 3);
    if (!output_filename)
    {
        perror("Failed to allocate memory for output filename");
        return NULL; // Or some default
    }

    strncpy(output_filename, input_filename, base_len);
    strcpy(output_filename + base_len, ".s");

    return output_filename;
}

int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        fprintf(stderr, "Usage: %s <input_minijava_file>\n", argv[0]);
        return 1; // Indicate error
    }

    const char *input_filename = argv[1];

    // Open the input file for lexer/parser
    yyin = fopen(input_filename, "r");
    if (!yyin)
    {
        perror("Could not open input file");
        return 1; // Indicate error
    }

    printf("Lexing and parsing started for: %s\n", input_filename);
    // Call the parser. It will internally call the lexer.
    printf("Printing Tokens and Lexemes: \n");
    int parse_result = yyparse();

    // Close yyin
    fclose(yyin);
    yyin = NULL; // Good practice to nullify closed FILE*

    // If yylex_destroy exists and is needed (check your lexer.l or lexer.yy.c)
    // if (yylex_destroy) {
    //     yylex_destroy();
    // }

    if (parse_result == 0)
    {
        printf("Parsing successful!\n");

        if (root_ast_node == NULL)
        {
            fprintf(stderr, "Error: AST root is NULL after successful parsing. No AST was built.\n");
            return 1;
        }

        printf("Printing AST: ");

        print_ast (root_ast_node, 0);

        init_symbol_table();
        init_tac_generator(); // Initialize TAC generator state

        printf("Starting semantic analysis...\n");
        analyze_semantics(root_ast_node);

        if (semantic_error_count == 0)
        {
            printf("Semantic analysis successful! No errors found.\n");

            // --- Intermediate Representation (IR) Generation Phase ---
            printf("Starting IR generation...\n");
            generate_ir(root_ast_node); // Populates global tac_head

            if (tac_head != NULL)
            {
                printf("IR generation successful! Generated Three-Address Code:\n");
                print_tac_code();

                // --- Code Generation Phase (x86 Assembly) ---
                printf("Starting x86 code generation...\n");
                char *output_asm_filename = get_output_asm_filename(input_filename);
                if (output_asm_filename)
                {
                    generate_x86_assembly(tac_head, output_asm_filename);
                    printf("Assembly output should be in: %s\n", output_asm_filename);
                    free(output_asm_filename); // Free the allocated filename string
                }
                else
                {
                    fprintf(stderr, "Error: Could not determine output assembly filename. Skipping x86 generation.\n");
                }
                // --- END Code Generation Phase ---
            }
            else
            {
                fprintf(stderr, "Info: IR generation did not produce any TAC instructions (empty program or error in IR gen?).\n");
            }
        }
        else
        {
            fprintf(stderr, "Semantic analysis found %d error(s). Compiler front-end failed.\n", semantic_error_count);
            // Free resources before exiting due to semantic errors
            if (root_ast_node != NULL)
                free_ast(root_ast_node);
            if (tac_head != NULL)
                free_tac_code();
            free_symbol_table();
            return 1; // Indicate semantic errors
        }
    }
    else
    {
        fprintf(stderr, "Parsing failed! Syntax errors detected. Compiler front-end failed.\n");
        // Resources like root_ast_node might not be fully formed or null
        // If AST partial creation happens, it should be freed.
        // For simplicity here, assuming parser failure means minimal resource allocation beyond lexer.
        if (root_ast_node != NULL)
            free_ast(root_ast_node); // Attempt to free if it got partially built
        // TAC wouldn't be generated yet
        // Symbol table might have partial entries, depends on your init/failure handling
        // init_symbol_table might have been called even before parse_result is checked.
        // Consider where init_symbol_table is called. If before yyparse, then free_symbol_table here.
        // Based on current structure, init_symbol_table is after parse success, so not needed here.
        return 1; // Indicate parsing failure
    }

    // --- Resource Cleanup ---
    if (root_ast_node != NULL)
    {
        printf("Freeing AST memory...\n");
        free_ast(root_ast_node);
        root_ast_node = NULL;
    }

    if (tac_head != NULL)
    {
        printf("Freeing TAC memory...\n");
        free_tac_code(); // tac_head will be set to NULL inside this function
    }

    printf("Freeing symbol table...\n");
    free_symbol_table();

    printf("Compilation process finished.\n");
    return 0; // Indicate overall success
}